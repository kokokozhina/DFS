\documentclass[bachelor, och, pract, times]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    nir      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usetikzlibrary{shadows, trees, arrows, automata, positioning}

\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Обход графа в глубину}

% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Кожиной Ольги Олеговны}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент, к.\,ф.-м.\,н.} %должность, степень, звание
\saname{Ю.\,Н.\,Кондратова}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{руководитель ЦОПП}
\paname{М.\,Р.\,Мирзаянов}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{4}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{педагогическая}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{12.07.2017}
\practFinish{21.07.2017}

% Год выполнения отчета
\date{2017}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr

% Раздел "Введение"
\intro
Целью практики является освоение алгоритма поиска в глубину и его приложений. В результате прохождения практики были получены навыки решения типовых задач:
\begin{itemize}
	\item Поиск компонент связанности;
	\item Поиск точек сочленения и мостов;
	\item Определение отношения вложенности между вершинами;
	\item Топологическая сортировка;
	\item Ориентация графа;
	\item Проверка графа на ацикличность.
\end{itemize}

\section{Теоретические сведения}

Обход~--- алгоритм, который посещает каждую вершину по одному разу в некотором порядке.

Обход графа в ширину можно сравнить с распространением огня, а обход в глубину~--- с человеком, который ходит по лабиринту, пытаясь найти выход.

Поиск в глубину (DFS~--- \textit{Depth First Search}) оперирует тремя цветами: белым, серым и черным. Изначально вершины являются белыми (непосещенными), а в процессе обхода они темнеют. Вершина становится серой, когда обход впервые обнаружил эту вершину. Вершина становится черной, когда обход завершил окончательно обработку этой вершины и покинул ее навсегда.

\subsection{Стратегия поиска в глубину}
Стратегия поиска в глубину, как следует из её названия состоит в том, чтобы идти <<в глубь>> графа, насколько это возможно, т.\,е. находясь в текущей (серой) вершине рассматриваем список <<соседей>> и рекурсивно переходим в белую вершину, делая её серой. Когда просмотр списка <<соседей>> завершен, следовательно, нет соседних белых вершин, делаем текущую вершину черной и покидаем её, возвращаясь по стеку рекурсии вверх. Наглядно эта стратегия продемонстрирована на рисунке~\ref{pic_3}.
\begin{figure}[!ht]    \centering
    \includegraphics[scale=0.75]{tree_g.jpg}
    \caption{Пример обхода графа в глубину}\label{pic_3}
\end{figure}

При хранении графа списками смежности обход в глубину, запущенный из вершины графа, посещает все вершины, достижимые из данной, и строит дерево поиска в глубину. В этом случае временная сложность алгоритма составит $O(x + y)$, где $x$~--- количество вершин, достижимых из заданной, а $y$~--- количество ребер (дуг), исходящих из x посещенных вершин, или $O(n + m)$, если посещен весь граф, $n$~--- общее количество вершин, а $m$~--- общее количество ребер.

Ниже представлен псевдокод DFS, где $u$~--- вершина, из которой осуществляется обход в глубину, $pred$~--- вершина"=предок для $u$ (если DFS первоначально запускается из неё, то она является предком для самой себя), $p$~--- массив предков, $color$~--- массив цветов.
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=2pt]
dfs(u, pred)
	color[u] = GRAY
	p[u] = pred
	for (v : g[u]) //v — сосед u
		if (color[v] == WHITE)
			dfs(v, u)
	color[u] = BLACK
\end{Verbatim}

Удобно инициализировать массив предков $p[i] = -1$, т.\,е. если $p[i] = -1$, то предок не определен.

Таким образом, если корень дерева располагается в узле 1, то вызов будет представлять собой команду $dfs(1, 1)$.

\subsection{Различия между BFS и DFS}
Оба эти обхода работают за $O(n + m)$ и просты в реализации, однако:
\begin{enumerate}
\item В отличиe от обхода в ширину, дерево обхода в глубину не кодирует информацию о кратчайших путях, а содержит информацию о произвольных путях из корня.
\item Обход в глубину в большой степени использует и анализирует циклическую структуру графа, что делает его фундаментом для более сложных алгоритмов анализа циклов, мостов, точек сочленения, компонент двусвязности и т.\,д.
\end{enumerate}

\subsection{Вариации написания DFS}
Минимальная версия DFS записывается довольно коротко, что является причиной её частого использования. Такая реализация достаточна для выделения компонент связности, поэтому нет необходимости для использования массива предков и трех цветов. Ниже представлен псевдокод минимальной версии DFS.
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=2pt]
dfs(u)
	used[u] = true
	for (v : g[u]) 
		if (!used[v])
			dfs(v)
\end{Verbatim}

Полная версия DFS для каждой вершины записывает две метки времени: момент входа в вершину (вершина меняет цвет с белого на серый) и момент выхода из неё (вершина меняет цвет с серого на черный). Все моменты времени~--- различные последовательные числа, поэтому для поддержания таймера времени потребуется глобальная переменная $T = 0$. Здесь $tin$~--- массив времен входов, $tout$~--- массив времен выходов. Ниже представлен псевдокод полной версии DFS, а также иллюстрации дерева с временными метками (рис.~\ref{pic_4}) и временных отрезков этого дерева (рис.~\ref{pic_5}).
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=2pt]
T = 0
dfs(u, pred)
	color[u] = GRAY
	p[u] = pred
	tin[u] = T++
	for (v : g[u])
		if (color[v] == WHITE)
			dfs(v, u)
	color[u] = BLACK
	tout[u] = T++
\end{Verbatim}

\begin{figure}[!ht]    \centering
    \includegraphics[scale=1]{timestamps.png}
    \caption{Дерево поиска в глубину с временными метками}\label{pic_4}
\end{figure}

\begin{figure}[!ht]    \centering
    \includegraphics[scale=1]{timeline.png}
    \caption{Временные отрезки дерева поиска}\label{pic_5}
\end{figure}

Временные метки кодируют информацию об иерархии для дерева поиска в глубину. Любая пара отрезков времен ($[tin[i], tout[i]]$) вершин либо не пересекается (отрезки идут один за другим), либо один отрезок вложен в другой. Если отрезок времен вершины $v$ вложен в отрезок времен вершины $u$, то $u$~--- предок $v$ в дереве поиска в глубину. Если отрезки не пересекаются, то никакая из двух вершин не является предком другой и эти вершины лежат в разных поддеревьях.

\subsection{Классификация ребер при DFS}
Поиск в глубину классифицирует ребра на основании их участия в DFS  при первом просмотре этого ребра.
Ребра бывают:
\begin{enumerate}
\item Древесные~--- ребра, образующие дерево поиска в глубину (ведут из серой вершины в белую). Пример: ребро $0\rightarrow1$.
\item Обратные~--- ребра, которые ведут вверх по дереву, замыкают цикл (ведут из серой вершины в серую). Пример: ребро $3\rightarrow1$.
\item Прямые~--- ребра, которые ведут вниз по дереву (ведут из серой вершины в черную). Пример: ребро $0\rightarrow2$.
\item Перекрестные~---  ребра, которые ведут от одного поддерева к другому (ведут из серой вершины в черную). Пример: ребро $4\rightarrow3$ (рисунок~\ref{pic_6}).
\end{enumerate}

\begin{figure}[!ht]    \centering
    \includegraphics[scale=1]{edges.png}
    \caption{Граф со всеми видами ребер}\label{pic_6}
\end{figure}

Различить два последних класса ребер можно легко на основании временных меток: если отрезки времен не вложены, значит, ребро перекрестное.

\textbf{Замечание:} в ориентированном графе есть цикл тогда и только тогда, когда существует обратное ребро.

DFS для неориентированного графа делит все ребра на 2 группы: древесные и обратные.



\subsection{Серия DFS}
Не сбрасывая цвета вершины, пройдем по всем вершинам вызывая DFS из каждой белой в текущий момент времени вершины. Ниже представлена реализация серии DFS, где $V$~--- список всех вершин.
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=2pt]
color[] <- WHITE
for (u : V)
	if (color[u] == WHITE)
		dfs(u, u)
\end{Verbatim}

Так все вершины графа будут посещены, а также будет построен набор деревьев поиска в глубину, покрывающих все вершины графа. Суммарное время работы~--- $O(n + m)$. Серия поисков в глубину применяется для выделения компонент связанности графа.
	
\subsection{Топологическая сортировка}
Топологическая сортировка ориентированного ациклического графа представляет собой такое линейное упорядочивание всех его вершин, что если граф $G$ содержит ребро $(u, v)$, то $u$ при таком упорядочивании располагается до $v$ (если граф содержит цикл, такая сортировка невозможна). Топологическую сортировку графа можно рассматривать как такое упорядочивание его вершин вдоль горизонтальной линии, что все ребра направлены слева направо. 

Ориентированные ациклические графы используются во многих приложениях для указания последовательности событий. На рисунке~\ref{pic_1} приведен пример графа, построенного профессором Рассеянным для утреннего одевания. Ребро $(u, v)$ показывает, что ведь $u$ должна быть одета раньше вещи $v$. Топологическая сортировка (рисунок~\ref{pic_2}) этого графа дает нам порядок одевания~\cite{Kormen}. 
\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{toposort1.png}
    \caption{Граф утреннего одевания}\label{pic_1}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=1]{toposort2.png}
    \caption{Топологическая сортировка графа утреннего одевания}\label{pic_2}
\end{figure}

Алгоритм топологической сортировки будет следующий:
\begin{enumerate}
\item Произведем серию DFS. Если в процессе DFS была попытка пойти из серой вершины в серую, то топологической сортировки не существует.
\item Отсортируем все вершины по убыванию времени окончания обработки. Найденный порядок и есть топологическая сортировка.
\end{enumerate}

\textbf{Замечание:} добавляя вершину в некоторый вектор в момент времени окончания её обработки и перевернув в конце этот вектор, можно легко получить искомую последовательность.

\section{Примеры задач и их решения}

\subsection{Компоненты связности}

\textbf{Условие.} 

ограничение по времени на тест "--- 0.5 секунд

ограничение по памяти на тест "--- 256 мегабайт

ввод "--- стандартный ввод

вывод "--- стандартный вывод

Вам задан неориентированный граф с $n$ вершинами и $m$ ребрами. В графе отсутствуют петли и кратные ребра. Определите компоненты связности заданного графа.

\textbf{Входные данные.} Граф задан во входном файле следующим образом: первая строка содержит числа $n$ и $m\,(1\leqslant n\leqslant 1000)$. Каждая из следующих m строк содержит описание ребра "--- два целых числа из диапазона от $1$ до $n$ "--- номера концов ребра.

\textbf{Выходные данные.} На первой строке выходного файла выведите число $l$ "--- количество компонент связности заданного графа. На следующей строке выведите $n$ чисел из диапазона от $1$ до $l$ "--- номера компонент связности, которым принадлежат соответствующие вершины. Компоненты связности следует занумеровать от $1$ до $l$ произвольным образом.

\textbf{Решение.} Заинициализируем переменную $сnt = 0$. Во вспомогательном векторе \verb|used| будем хранить номер компоненты связности, к которой она принадлежит. Произведем серию обходов в глубину из каждой непомеченной вершины, увеличивая каждый раз в цикле серии значение счетчика $cnt$ и передавая его в функцию $dfs(i, cnt)$, чтобы все узлы компоненты с корнем в $i$ принадлежали компоненте с номером $cnt$. Выведем на экран вектор \verb|used| "--- это и будет ответом.

Полный код программы приведен в приложении~\ref{A}.

\subsection{Обход в глубину}

\textbf{Условие.} 

ограничение по времени на тест "--- 0.5 секунд

ограничение по памяти на тест "--- 256 мегабайт

ввод "--- стандартный ввод

вывод "--- стандартный вывод

Задан неориентированный граф из $n$ вершин. Требуется найти путь из вершины $v_1$ в вершину $v_2$, при этом обязательно использовать обход в глубину. Обход в глубину надо реализовать таким образом, что для очередной вершины графа в обходе надо просматривать все смежные с ней вершины в порядке увеличения их номера. То есть требуется реализовать <<обычный>> обход в глубину.

\textbf{Входные данные.} В первой строке через пробел записано три натуральных числа $n, v_1, v_2\,(1 \leqslant n \leqslant 100, 1 \leqslant v_1, v_2\leqslant n)$.

В каждой из следующих $n$ строк записано по $n$ чисел "--- матрица смежности графа. <<1>> обозначает, что между соответствующими вершинами есть ребро, <<0>> "--- что нет.


\textbf{Выходные данные.} В первую строку выведите длину пути (количество ребер графа в пути). Во вторую строку выведите сам путь начиная с вершины $v_1$ и заканчивая вершиной $v_2$.

Выведите единственную строку $-1$, если пути нет.

\textbf{Решение.} Считаем матрицу смежности, заведем вектор предков \verb|p| и вектор \verb|used| для помечивания вершин. Запустим рекурсивную функцию \verb|dfs|, принимающую два аргумента: стартовую вершину $u$ и вершину"=предок $pr$. Пройдемся в цикле по смежным с $u$ вершинам, если они не были помечены, вызовем \verb|dfs| от них. Выведем ответ, воспользовавшись вектором предков \verb|p|. Если последний добавленный в вектор ответа  \verb|ans| элемент равен $-1$, то выводим $-1$, иначе выводим размер вектора \verb|ans| и его самого в обратном порядке.

Полный код программы приведен в приложении~\ref{B}.

\subsection{Точки сочленения}

\textbf{Условие.} 

ограничение по времени на тест "--- 0.5 секунд

ограничение по памяти на тест "--- 256 мегабайт

ввод "--- стандартный ввод

вывод "--- стандартный вывод

Вам задан неориентированный граф с $n$ вершинами и $m$ ребрами. В графе отсутствуют петли и кратные ребра. Известно, что граф связный.

Найдите все точки сочленения в заданном графе, то есть такие вершины, удаление которых ведет к увеличению числа компонент связности.

\textbf{Входные данные.} Граф задан во входном файле следующим образом: первая строка содержит числа $n$ и $m\,(1\leqslant n\leqslant 200)$. Каждая из следующих m строк содержит описание ребра "--- два целых числа из диапазона от $1$ до $n$ "--- номера концов ребра.

\textbf{Выходные данные.} В первую строку выведите число $c$ "--- количество точек сочленения в заданном графе.

В следующую строку выведите $c$ целых чисел "--- номера вершин, которые являются точками сочленения, в возрастающем порядке.

\textbf{Решение.} Воспользуемся следующим наивным способом нахождения точек сочленения: 
\begin{enumerate}
\item Посчитаем общее количество компонент связности серией DFS;
\item Запретим последовательно использовать каждую из вершин (например, пометив её черным цветом), а затем также для каждого из $n$ вариантов запрета серией DFS найдем точки сочленения (если число компонент связности увеличилось при запрете использования вершины $i$, то вершина $i$ есть точка сочленения).
\end{enumerate}

Однако в данной задаче можно опустить первый пункт (граф связный по условию). 

Полный код программы приведен в приложении~\ref{C}.

\subsection{Проверка на двудольность}

\textbf{Условие.} 

ограничение по времени на тест "--- 2 секунды

ограничение по памяти на тест "--- 256 мегабайт

ввод "--- стандартный ввод

вывод "--- стандартный вывод

Дан неориентированный граф. Необходимо проверить, является ли он двудольным, т.\,е. можно ли разбить его вершины на два множества так, чтобы никакие две вершины внутри каждого множества не были смежны.

\textbf{Входные данные.} Граф задан во входном файле следующим образом: первая строка содержит числа $n$ и $m\,(1\leqslant n\leqslant 200)$. Каждая из следующих m строк содержит описание ребра "--- два целых числа из диапазона от $1$ до $n$ "--- номера концов ребра.

В первой строке содержится натуральное число $T\,(1\leqslant T\leqslant 10000)$ "--- количество наборов тестовых данных. Во первой строке каждого набора записано два целых числа $N$ и $M\,(1\leqslant N\leqslant 100000, 0\leqslant M\leqslant 100000)$ "--- число вершин и ребер в графе соответственно.

В последующих $M$ строках записано по паре номеров вершин, соединенных ребром. Номера вершин "--- это целые числа от $1$ до $N$. Гарантируется, что в графе не содержится петель и мультиребер. Известно, что сумма значений $N$ по всем $T$ тестовым наборам не превосходит $100000$, а сумма значений $M$ не превосходит $200000$.

\textbf{Выходные данные.} Выведите $T$ строк, по одной для каждого набора входных данных. Если граф двудольный, выводите <<YES>>, иначе <<NO>> (без кавычек).

\textbf{Решение.} Произведем серию поисков в глубину, используя вектор цветов \verb|color| и вспомогательный параметр $c$, принимающий значение $0$ или $1$. При заходе в функцию инициализируем $color[u] = c$ и сменим значение, сложив $c$ по модулю $2$ с $1$. Рассмотрим всех соседей вершины: если хотя бы один из них имеет такой же цвет, как у данной вершины, то ответ <<NO>>. Заметим, что граф двудольный тогда и только тогда, когда все циклы в нем четной длины.

Полный код программы приведен в приложении~\ref{G}.

\newpage

% Раздел "Заключение"
\conclusion
В ходе практики были изучены свойства алгоритма поиска в глубину, а также его преимущества по сравнению с алгоритмом обхода в ширину. Практические задачи были решены при помощи различных модификаций алгоритма DFS, причем основными являются:
\begin{itemize}
	\item использование булевого массива \verb|used| (поиск компонент связанности графа);
	\item использование цветов для пометки вершин (проверка графа на ацикличность);
	\item использование массивов для хранения меток времени (определение вложенности вершин).
\end{itemize}

% Список литературы
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix
\lstset{numbers = left, numberstyle = \tiny, language = C++, breaklines = true, basicstyle = \footnotesize}

\section{Программный код задачи <<Компоненты связности>>}\label{A}
\lstinputlisting{A.cpp}

\section{Программный код задачи <<Обход в глубину>>}\label{B}
\lstinputlisting{B.cpp}

\section{Программный код задачи <<Точки сочленения>>}\label{C}
\lstinputlisting{C.cpp}

\section{Программный код задачи <<Проверка на двудольность>>}\label{G}
\lstinputlisting{G.cpp}

\end{document}
